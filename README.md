# Surface Rendering

### Introduction

The purpose of this program is to render Bezier surfaces with different triangulation sample rates. The program uses an input file containing 1-5 light sources and up to 36 Bezier surfaces. Each surface is triangulated with an amount of 10 samples per edge by default. In such a case, a surface contains 10x10 vertices and 9x9x2 triangles. The program allows modification of this sample rate using "W" and "S" buttons in a range from 2 to 80. The rotation on horizontal axis of the final object is possible with "R" and "F" buttons. User can increase the size of the object on x-y axises without modifying z values by using "E" and "D" buttons. I also configured "Q" and "A" buttons to switch between wireframe and standard versions of the surface.

### Implementation

Before starting coding, I had to configure my environment to run OpenGL programs. I am using a Windows 11 machine with Ubuntu WSL2. Since I was previously using WSL2 for development, I decided to keep using it. Although I have a RTX3050Ti GPU, I could not manage to use OpenGL 4.6. After a day spent searching a reliable method to use OpenGL on WSL2, I managed to set up Mesa implementation of OpenGL 4.2. This most probably causes major performance limitations but it did not cause problem for this project.

I started my implementation from an example OpenGL code provided in class. The first thing I did was to set up view and projection matrices correctly and draw a single triangle. After dealing with that and also parsing the input, I started to design how I triangulate and send the surfaces to the GPU. Since each surface is identical except for the control points, I decided to use "glDrawElementsInstanced" call which draws the same element multiple times. Also since coordinates of vertices were not defined at CPU side, I only provided indices I generated from a simple triangulation algorithm I created, in a single vertex buffer object. Triangulation algorithm starts creating triangle indices starting from the top left corner of the surfaces when we look from the positive z axis. Since I used "glDrawElementsInstanced", focusing on a single surface was enough for any work done at CPU side.
